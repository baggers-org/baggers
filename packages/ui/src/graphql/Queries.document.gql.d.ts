/* bd71c64b5de230ee46fd1143d6a19355ea026d96
 * This file is automatically generated by graphql-let. */

import * as Apollo from '@apollo/client';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    Date: any;
    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    JSON: any;
    /** The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field. */
    MongoID: any;
    /** The string representation of JavaScript regexp. You may provide it with flags "/^abc.*\/i" or without flags like "^abc.*". More info about RegExp characters and flags: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
    RegExpAsString: any;
};
export declare type CreateOnePortfolioInput = {
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
    numberOfPositions?: Maybe<Scalars['Float']>;
};
export declare type CreateOnePortfolioPayload = {
    __typename?: 'CreateOnePortfolioPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Created document */
    record?: Maybe<Portfolio>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type CreateOnePositionInput = {
    portfolio: Scalars['MongoID'];
    symbol: Scalars['MongoID'];
    direction?: Maybe<EnumPositionDirection>;
    averagePrice: Scalars['Float'];
    brokerFees?: Maybe<Scalars['Float']>;
    positionSize: Scalars['Float'];
    openDate?: Maybe<Scalars['Date']>;
    closeDate?: Maybe<Scalars['Date']>;
    _id?: Maybe<Scalars['MongoID']>;
};
export declare type CreateOnePositionPayload = {
    __typename?: 'CreateOnePositionPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Created document */
    record?: Maybe<Position>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare enum Direction {
    Next = "next",
    Last = "last"
}
export declare enum EnumPositionDirection {
    Long = "long",
    Short = "short"
}
export declare type ErrorInterface = {
    /** Generic error message */
    message?: Maybe<Scalars['String']>;
};
export declare type FilterFindManyPortfolioInput = {
    owner?: Maybe<Scalars['String']>;
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
    numberOfPositions?: Maybe<Scalars['Float']>;
    positions?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
    _id?: Maybe<Scalars['MongoID']>;
    /** List of *indexed* fields that can be filtered via operators. */
    _operators?: Maybe<FilterFindManyPortfolioOperatorsInput>;
    OR?: Maybe<Array<FilterFindManyPortfolioInput>>;
    AND?: Maybe<Array<FilterFindManyPortfolioInput>>;
};
/** For performance reason this type contains only *indexed* fields. */
export declare type FilterFindManyPortfolioOperatorsInput = {
    owner?: Maybe<FilterFindManyPortfolioOwnerOperatorsInput>;
    _id?: Maybe<FilterFindManyPortfolio_IdOperatorsInput>;
};
export declare type FilterFindManyPortfolioOwnerOperatorsInput = {
    gt?: Maybe<Scalars['String']>;
    gte?: Maybe<Scalars['String']>;
    lt?: Maybe<Scalars['String']>;
    lte?: Maybe<Scalars['String']>;
    ne?: Maybe<Scalars['String']>;
    in?: Maybe<Array<Maybe<Scalars['String']>>>;
    nin?: Maybe<Array<Maybe<Scalars['String']>>>;
    regex?: Maybe<Scalars['RegExpAsString']>;
    exists?: Maybe<Scalars['Boolean']>;
};
export declare type FilterFindManyPortfolio_IdOperatorsInput = {
    gt?: Maybe<Scalars['MongoID']>;
    gte?: Maybe<Scalars['MongoID']>;
    lt?: Maybe<Scalars['MongoID']>;
    lte?: Maybe<Scalars['MongoID']>;
    ne?: Maybe<Scalars['MongoID']>;
    in?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
    nin?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
    exists?: Maybe<Scalars['Boolean']>;
};
export declare type MongoError = ErrorInterface & {
    __typename?: 'MongoError';
    /** MongoDB error message */
    message?: Maybe<Scalars['String']>;
    /** MongoDB error code */
    code?: Maybe<Scalars['Int']>;
};
export declare type Mutation = {
    __typename?: 'Mutation';
    /** Create one document with mongoose defaults, setters, hooks and validation */
    addPosition?: Maybe<CreateOnePositionPayload>;
    /** Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document. */
    removePosition?: Maybe<RemoveByIdPositionPayload>;
    removePositions?: Maybe<RemoveManyPositionPayload>;
    /** Create one document with mongoose defaults, setters, hooks and validation */
    createPortfolio?: Maybe<CreateOnePortfolioPayload>;
    /** Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it. */
    updatePortfolio?: Maybe<UpdateByIdPortfolioPayload>;
    /** Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document. */
    removePortfolio?: Maybe<RemoveByIdPortfolioPayload>;
};
export declare type MutationAddPositionArgs = {
    record: CreateOnePositionInput;
};
export declare type MutationRemovePositionArgs = {
    _id: Scalars['MongoID'];
};
export declare type MutationRemovePositionsArgs = {
    ids?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
};
export declare type MutationCreatePortfolioArgs = {
    record: CreateOnePortfolioInput;
};
export declare type MutationUpdatePortfolioArgs = {
    _id: Scalars['MongoID'];
    record: UpdateByIdPortfolioInput;
};
export declare type MutationRemovePortfolioArgs = {
    _id: Scalars['MongoID'];
};
export declare type PaginationInfo = {
    __typename?: 'PaginationInfo';
    currentPage: Scalars['Int'];
    perPage: Scalars['Int'];
    pageCount?: Maybe<Scalars['Int']>;
    itemCount?: Maybe<Scalars['Int']>;
    hasNextPage?: Maybe<Scalars['Boolean']>;
    hasPreviousPage?: Maybe<Scalars['Boolean']>;
};
export declare type Portfolio = {
    __typename?: 'Portfolio';
    owner?: Maybe<Scalars['String']>;
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
    numberOfPositions?: Maybe<Scalars['Float']>;
    positions?: Maybe<PositionPagination>;
    _id: Scalars['MongoID'];
};
export declare type PortfolioPositionsArgs = {
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
};
export declare type Position = {
    __typename?: 'Position';
    owner?: Maybe<Scalars['String']>;
    portfolio?: Maybe<Scalars['MongoID']>;
    symbol?: Maybe<Symbol>;
    direction?: Maybe<EnumPositionDirection>;
    exposure?: Maybe<Scalars['Float']>;
    averagePrice?: Maybe<Scalars['Float']>;
    marketValue?: Maybe<Scalars['Float']>;
    costBasis?: Maybe<Scalars['Float']>;
    brokerFees?: Maybe<Scalars['Float']>;
    positionSize?: Maybe<Scalars['Float']>;
    profitLossUsd?: Maybe<Scalars['Float']>;
    profitLossPercent?: Maybe<Scalars['Float']>;
    dailyProfitLossUsd?: Maybe<Scalars['Float']>;
    openDate?: Maybe<Scalars['Date']>;
    closeDate?: Maybe<Scalars['Date']>;
    _id: Scalars['MongoID'];
};
/** List of items with pagination. */
export declare type PositionPagination = {
    __typename?: 'PositionPagination';
    /** Total object count. */
    count?: Maybe<Scalars['Int']>;
    /** Array of objects. */
    items?: Maybe<Array<Position>>;
    /** Information to aid in pagination. */
    pageInfo: PaginationInfo;
};
export declare type PositionsFilter = {
    portfolio?: Maybe<Scalars['MongoID']>;
    isEtf?: Maybe<Scalars['Boolean']>;
    exchange?: Maybe<Scalars['String']>;
    country?: Maybe<Scalars['String']>;
};
export declare enum PositionsSort {
    CostBasisAsc = "COST_BASIS_ASC",
    CostBasisDesc = "COST_BASIS_DESC",
    MarketValueAsc = "MARKET_VALUE_ASC",
    MarketValueDesc = "MARKET_VALUE_DESC",
    ProfitLossUsdAsc = "PROFIT_LOSS_USD_ASC",
    ProfitLossUsdDesc = "PROFIT_LOSS_USD_DESC",
    SymbolSymbolAsc = "SYMBOL_SYMBOL_ASC",
    SymbolSymbolDesc = "SYMBOL_SYMBOL_DESC",
    SymbolSecurityNameAsc = "SYMBOL_SECURITY_NAME_ASC",
    SymbolSecurityNameDesc = "SYMBOL_SECURITY_NAME_DESC",
    SymbolQuoteChangeAsc = "SYMBOL_QUOTE_CHANGE_ASC",
    SymbolQuoteChangeDesc = "SYMBOL_QUOTE_CHANGE_DESC",
    SymbolQuoteChangePercentAsc = "SYMBOL_QUOTE_CHANGE_PERCENT_ASC",
    SymbolQuoteChangePercentDesc = "SYMBOL_QUOTE_CHANGE_PERCENT_DESC",
    SymbolQuoteLatestPriceAsc = "SYMBOL_QUOTE_LATEST_PRICE_ASC",
    SymbolQuoteLatestPriceDesc = "SYMBOL_QUOTE_LATEST_PRICE_DESC",
    SymbolQuoteVolumeAsc = "SYMBOL_QUOTE_VOLUME_ASC",
    SymbolQuoteVolumeDesc = "SYMBOL_QUOTE_VOLUME_DESC"
}
export declare type Query = {
    __typename?: 'Query';
    myPositions?: Maybe<PositionPagination>;
    getPositions?: Maybe<PositionPagination>;
    myPortfolios: Array<Portfolio>;
    getPortfolioById?: Maybe<Portfolio>;
    searchSymbols?: Maybe<Array<Maybe<Symbol>>>;
    getTradingDate?: Maybe<TradingDateResponse>;
};
export declare type QueryMyPositionsArgs = {
    filter?: Maybe<PositionsFilter>;
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
};
export declare type QueryGetPositionsArgs = {
    filter?: Maybe<PositionsFilter>;
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
};
export declare type QueryMyPortfoliosArgs = {
    filter?: Maybe<FilterFindManyPortfolioInput>;
    skip?: Maybe<Scalars['Int']>;
    limit?: Maybe<Scalars['Int']>;
    sort?: Maybe<SortFindManyPortfolioInput>;
};
export declare type QueryGetPortfolioByIdArgs = {
    _id: Scalars['MongoID'];
};
export declare type QuerySearchSymbolsArgs = {
    search: Scalars['String'];
};
export declare type QueryGetTradingDateArgs = {
    from?: Maybe<Scalars['String']>;
    direction?: Maybe<Direction>;
};
export declare type Quote = {
    __typename?: 'Quote';
    symbol?: Maybe<Scalars['MongoID']>;
    change?: Maybe<Scalars['Float']>;
    changePercent?: Maybe<Scalars['Float']>;
    latestPrice?: Maybe<Scalars['Float']>;
    latestUpdate?: Maybe<Scalars['Float']>;
    extendedPrice?: Maybe<Scalars['Float']>;
    extendedUpdate?: Maybe<Scalars['Float']>;
    volume?: Maybe<Scalars['Float']>;
    companyName?: Maybe<Scalars['String']>;
    primaryExchange?: Maybe<Scalars['String']>;
    calculationPrice?: Maybe<Scalars['String']>;
    open?: Maybe<Scalars['Float']>;
    openTime?: Maybe<Scalars['Float']>;
    openSource?: Maybe<Scalars['String']>;
    close?: Maybe<Scalars['Float']>;
    closeTime?: Maybe<Scalars['Float']>;
    closeSource?: Maybe<Scalars['String']>;
    high?: Maybe<Scalars['Float']>;
    highTime?: Maybe<Scalars['Float']>;
    highSource?: Maybe<Scalars['String']>;
    low?: Maybe<Scalars['Float']>;
    lowTime?: Maybe<Scalars['Float']>;
    lowSource?: Maybe<Scalars['String']>;
    latestSource?: Maybe<Scalars['String']>;
    latestTime?: Maybe<Scalars['String']>;
    latestVolume?: Maybe<Scalars['Float']>;
    iexRealtimePrice?: Maybe<Scalars['Float']>;
    iexRealtimeSize?: Maybe<Scalars['Float']>;
    iexLastUpdated?: Maybe<Scalars['Float']>;
    delayedPrice?: Maybe<Scalars['Float']>;
    delayedPriceTime?: Maybe<Scalars['Float']>;
    oddLotDelayedPrice?: Maybe<Scalars['Float']>;
    oddLotDelayedPriceTime?: Maybe<Scalars['Float']>;
    extendedChange?: Maybe<Scalars['Float']>;
    extendedChangePercent?: Maybe<Scalars['Float']>;
    extendedPriceTime?: Maybe<Scalars['Float']>;
    previousClose?: Maybe<Scalars['Float']>;
    previousVolume?: Maybe<Scalars['Float']>;
    iexMarketPercent?: Maybe<Scalars['Float']>;
    iexVolume?: Maybe<Scalars['Float']>;
    avgTotalVolume?: Maybe<Scalars['Float']>;
    iexBidPrice?: Maybe<Scalars['Float']>;
    iexBidSize?: Maybe<Scalars['Float']>;
    iexAskPrice?: Maybe<Scalars['Float']>;
    iexAskSize?: Maybe<Scalars['Float']>;
    iexOpen?: Maybe<Scalars['Float']>;
    iexOpenTime?: Maybe<Scalars['Float']>;
    iexClose?: Maybe<Scalars['Float']>;
    iexCloseTime?: Maybe<Scalars['Float']>;
    marketCap?: Maybe<Scalars['Float']>;
    peRatio?: Maybe<Scalars['Float']>;
    week52High?: Maybe<Scalars['Float']>;
    week52Low?: Maybe<Scalars['Float']>;
    ytdChange?: Maybe<Scalars['Float']>;
    lastTradeTime?: Maybe<Scalars['Float']>;
    isUSMarketOpen?: Maybe<Scalars['Boolean']>;
    _id: Scalars['MongoID'];
};
export declare type RemoveByIdPortfolioPayload = {
    __typename?: 'RemoveByIdPortfolioPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Removed document */
    record?: Maybe<Portfolio>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type RemoveByIdPositionPayload = {
    __typename?: 'RemoveByIdPositionPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Removed document */
    record?: Maybe<Position>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type RemoveManyPositionPayload = {
    __typename?: 'RemoveManyPositionPayload';
    /** Affected documents number */
    numAffected?: Maybe<Scalars['Int']>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type RuntimeError = ErrorInterface & {
    __typename?: 'RuntimeError';
    /** Runtime error message */
    message?: Maybe<Scalars['String']>;
};
export declare enum SortFindManyPortfolioInput {
    IdAsc = "_ID_ASC",
    IdDesc = "_ID_DESC",
    OwnerAsc = "OWNER_ASC",
    OwnerDesc = "OWNER_DESC"
}
export declare type Symbol = {
    __typename?: 'Symbol';
    symbol?: Maybe<Scalars['String']>;
    securityName?: Maybe<Scalars['String']>;
    isEtf?: Maybe<Scalars['Boolean']>;
    exchange?: Maybe<Scalars['String']>;
    country?: Maybe<Scalars['String']>;
    quote?: Maybe<Quote>;
    _id: Scalars['MongoID'];
};
export declare type TradingDateResponse = {
    __typename?: 'TradingDateResponse';
    date?: Maybe<Scalars['String']>;
    settlementDate?: Maybe<Scalars['String']>;
};
export declare type UpdateByIdPortfolioInput = {
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
    numberOfPositions?: Maybe<Scalars['Float']>;
};
export declare type UpdateByIdPortfolioPayload = {
    __typename?: 'UpdateByIdPortfolioPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Updated document */
    record?: Maybe<Portfolio>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type ValidationError = ErrorInterface & {
    __typename?: 'ValidationError';
    /** Combined error message from all validators */
    message?: Maybe<Scalars['String']>;
    /** List of validator errors */
    errors?: Maybe<Array<ValidatorError>>;
};
export declare type ValidatorError = {
    __typename?: 'ValidatorError';
    /** Validation error message */
    message?: Maybe<Scalars['String']>;
    /** Source of the validation error from the model path */
    path?: Maybe<Scalars['String']>;
    /** Field value which occurs the validation error */
    value?: Maybe<Scalars['JSON']>;
    /** Input record idx in array which occurs the validation error. This `idx` is useful for createMany operation. For singular operations it always be 0. For *Many operations `idx` represents record index in array received from user. */
    idx: Scalars['Int'];
};
export declare type PortfolioSummaryFragment = ({
    __typename?: 'Portfolio';
} & Pick<Portfolio, 'cash' | 'private' | 'owner' | 'name' | 'description' | 'totalValue' | 'numberOfPositions'>);
export declare type SymbolSummaryFragment = ({
    __typename?: 'Symbol';
} & Pick<Symbol, 'symbol' | 'securityName' | 'exchange' | 'country'>);
export declare type FullPositionFragment = ({
    __typename?: 'Position';
} & Pick<Position, 'profitLossPercent' | 'profitLossUsd' | 'dailyProfitLossUsd' | 'averagePrice' | 'openDate' | 'closeDate' | 'direction' | 'costBasis' | 'positionSize' | 'exposure' | 'marketValue'> & {
    symbol?: Maybe<({
        __typename?: 'Symbol';
    } & Pick<Symbol, '_id'> & {
        quote?: Maybe<({
            __typename?: 'Quote';
        } & Pick<Quote, '_id' | 'latestPrice' | 'changePercent'>)>;
    } & SymbolSummaryFragment)>;
});
export declare type AllPageInfoFragment = ({
    __typename?: 'PaginationInfo';
} & Pick<PaginationInfo, 'currentPage' | 'perPage' | 'pageCount' | 'itemCount' | 'hasNextPage' | 'hasPreviousPage'>);
export declare type MyPortfoliosQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MyPortfoliosQuery = ({
    __typename?: 'Query';
} & {
    myPortfolios: Array<({
        __typename?: 'Portfolio';
    } & Pick<Portfolio, '_id'> & {
        positions?: Maybe<({
            __typename?: 'PositionPagination';
        } & Pick<PositionPagination, 'count'> & {
            items?: Maybe<Array<({
                __typename?: 'Position';
            } & Pick<Position, '_id'> & FullPositionFragment)>>;
        })>;
    } & PortfolioSummaryFragment)>;
});
export declare type MyPortfoliosSummaryQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MyPortfoliosSummaryQuery = ({
    __typename?: 'Query';
} & {
    myPortfolios: Array<({
        __typename?: 'Portfolio';
    } & Pick<Portfolio, '_id'> & PortfolioSummaryFragment)>;
});
export declare type GetPortfolioSummaryByIdQueryVariables = Exact<{
    id: Scalars['MongoID'];
}>;
export declare type GetPortfolioSummaryByIdQuery = ({
    __typename?: 'Query';
} & {
    getPortfolioById?: Maybe<({
        __typename?: 'Portfolio';
    } & Pick<Portfolio, '_id'> & PortfolioSummaryFragment)>;
});
export declare type GetPortfolioByIdQueryVariables = Exact<{
    id: Scalars['MongoID'];
}>;
export declare type GetPortfolioByIdQuery = ({
    __typename?: 'Query';
} & {
    getPortfolioById?: Maybe<({
        __typename?: 'Portfolio';
    } & Pick<Portfolio, '_id'> & {
        positions?: Maybe<({
            __typename?: 'PositionPagination';
        } & {
            items?: Maybe<Array<({
                __typename?: 'Position';
            } & Pick<Position, '_id'> & FullPositionFragment)>>;
        })>;
    } & PortfolioSummaryFragment)>;
});
export declare type GetPositionsQueryVariables = Exact<{
    filter?: Maybe<PositionsFilter>;
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
}>;
export declare type GetPositionsQuery = ({
    __typename?: 'Query';
} & {
    getPositions?: Maybe<({
        __typename: 'PositionPagination';
    } & Pick<PositionPagination, 'count'> & {
        items?: Maybe<Array<({
            __typename?: 'Position';
        } & Pick<Position, '_id'> & FullPositionFragment)>>;
    })>;
});
export declare type SearchSymbolsQueryVariables = Exact<{
    search: Scalars['String'];
}>;
export declare type SearchSymbolsQuery = ({
    __typename?: 'Query';
} & {
    searchSymbols?: Maybe<Array<Maybe<({
        __typename?: 'Symbol';
    } & Pick<Symbol, '_id'> & SymbolSummaryFragment)>>>;
});
export declare const PortfolioSummaryFragmentDoc: Apollo.DocumentNode;
export declare const SymbolSummaryFragmentDoc: Apollo.DocumentNode;
export declare const FullPositionFragmentDoc: Apollo.DocumentNode;
export declare const AllPageInfoFragmentDoc: Apollo.DocumentNode;
export declare const MyPortfoliosDocument: Apollo.DocumentNode;
/**
 * __useMyPortfoliosQuery__
 *
 * To run a query within a React component, call `useMyPortfoliosQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyPortfoliosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyPortfoliosQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMyPortfoliosQuery(baseOptions?: Apollo.QueryHookOptions<MyPortfoliosQuery, MyPortfoliosQueryVariables>): Apollo.QueryResult<MyPortfoliosQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMyPortfoliosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyPortfoliosQuery, MyPortfoliosQueryVariables>): Apollo.QueryTuple<MyPortfoliosQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MyPortfoliosQueryHookResult = ReturnType<typeof useMyPortfoliosQuery>;
export declare type MyPortfoliosLazyQueryHookResult = ReturnType<typeof useMyPortfoliosLazyQuery>;
export declare type MyPortfoliosQueryResult = Apollo.QueryResult<MyPortfoliosQuery, MyPortfoliosQueryVariables>;
export declare const MyPortfoliosSummaryDocument: Apollo.DocumentNode;
/**
 * __useMyPortfoliosSummaryQuery__
 *
 * To run a query within a React component, call `useMyPortfoliosSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyPortfoliosSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyPortfoliosSummaryQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMyPortfoliosSummaryQuery(baseOptions?: Apollo.QueryHookOptions<MyPortfoliosSummaryQuery, MyPortfoliosSummaryQueryVariables>): Apollo.QueryResult<MyPortfoliosSummaryQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMyPortfoliosSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyPortfoliosSummaryQuery, MyPortfoliosSummaryQueryVariables>): Apollo.QueryTuple<MyPortfoliosSummaryQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MyPortfoliosSummaryQueryHookResult = ReturnType<typeof useMyPortfoliosSummaryQuery>;
export declare type MyPortfoliosSummaryLazyQueryHookResult = ReturnType<typeof useMyPortfoliosSummaryLazyQuery>;
export declare type MyPortfoliosSummaryQueryResult = Apollo.QueryResult<MyPortfoliosSummaryQuery, MyPortfoliosSummaryQueryVariables>;
export declare const GetPortfolioSummaryByIdDocument: Apollo.DocumentNode;
/**
 * __useGetPortfolioSummaryByIdQuery__
 *
 * To run a query within a React component, call `useGetPortfolioSummaryByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortfolioSummaryByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortfolioSummaryByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useGetPortfolioSummaryByIdQuery(baseOptions: Apollo.QueryHookOptions<GetPortfolioSummaryByIdQuery, GetPortfolioSummaryByIdQueryVariables>): Apollo.QueryResult<GetPortfolioSummaryByIdQuery, Exact<{
    id: any;
}>>;
export declare function useGetPortfolioSummaryByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortfolioSummaryByIdQuery, GetPortfolioSummaryByIdQueryVariables>): Apollo.QueryTuple<GetPortfolioSummaryByIdQuery, Exact<{
    id: any;
}>>;
export declare type GetPortfolioSummaryByIdQueryHookResult = ReturnType<typeof useGetPortfolioSummaryByIdQuery>;
export declare type GetPortfolioSummaryByIdLazyQueryHookResult = ReturnType<typeof useGetPortfolioSummaryByIdLazyQuery>;
export declare type GetPortfolioSummaryByIdQueryResult = Apollo.QueryResult<GetPortfolioSummaryByIdQuery, GetPortfolioSummaryByIdQueryVariables>;
export declare const GetPortfolioByIdDocument: Apollo.DocumentNode;
/**
 * __useGetPortfolioByIdQuery__
 *
 * To run a query within a React component, call `useGetPortfolioByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortfolioByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortfolioByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useGetPortfolioByIdQuery(baseOptions: Apollo.QueryHookOptions<GetPortfolioByIdQuery, GetPortfolioByIdQueryVariables>): Apollo.QueryResult<GetPortfolioByIdQuery, Exact<{
    id: any;
}>>;
export declare function useGetPortfolioByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortfolioByIdQuery, GetPortfolioByIdQueryVariables>): Apollo.QueryTuple<GetPortfolioByIdQuery, Exact<{
    id: any;
}>>;
export declare type GetPortfolioByIdQueryHookResult = ReturnType<typeof useGetPortfolioByIdQuery>;
export declare type GetPortfolioByIdLazyQueryHookResult = ReturnType<typeof useGetPortfolioByIdLazyQuery>;
export declare type GetPortfolioByIdQueryResult = Apollo.QueryResult<GetPortfolioByIdQuery, GetPortfolioByIdQueryVariables>;
export declare const GetPositionsDocument: Apollo.DocumentNode;
/**
 * __useGetPositionsQuery__
 *
 * To run a query within a React component, call `useGetPositionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPositionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPositionsQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      sort: // value for 'sort'
 *      perPage: // value for 'perPage'
 *      page: // value for 'page'
 *   },
 * });
 */
export declare function useGetPositionsQuery(baseOptions?: Apollo.QueryHookOptions<GetPositionsQuery, GetPositionsQueryVariables>): Apollo.QueryResult<GetPositionsQuery, Exact<{
    filter?: PositionsFilter;
    sort?: PositionsSort;
    perPage?: number;
    page?: number;
}>>;
export declare function useGetPositionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPositionsQuery, GetPositionsQueryVariables>): Apollo.QueryTuple<GetPositionsQuery, Exact<{
    filter?: PositionsFilter;
    sort?: PositionsSort;
    perPage?: number;
    page?: number;
}>>;
export declare type GetPositionsQueryHookResult = ReturnType<typeof useGetPositionsQuery>;
export declare type GetPositionsLazyQueryHookResult = ReturnType<typeof useGetPositionsLazyQuery>;
export declare type GetPositionsQueryResult = Apollo.QueryResult<GetPositionsQuery, GetPositionsQueryVariables>;
export declare const SearchSymbolsDocument: Apollo.DocumentNode;
/**
 * __useSearchSymbolsQuery__
 *
 * To run a query within a React component, call `useSearchSymbolsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchSymbolsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchSymbolsQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export declare function useSearchSymbolsQuery(baseOptions: Apollo.QueryHookOptions<SearchSymbolsQuery, SearchSymbolsQueryVariables>): Apollo.QueryResult<SearchSymbolsQuery, Exact<{
    search: string;
}>>;
export declare function useSearchSymbolsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchSymbolsQuery, SearchSymbolsQueryVariables>): Apollo.QueryTuple<SearchSymbolsQuery, Exact<{
    search: string;
}>>;
export declare type SearchSymbolsQueryHookResult = ReturnType<typeof useSearchSymbolsQuery>;
export declare type SearchSymbolsLazyQueryHookResult = ReturnType<typeof useSearchSymbolsLazyQuery>;
export declare type SearchSymbolsQueryResult = Apollo.QueryResult<SearchSymbolsQuery, SearchSymbolsQueryVariables>;
