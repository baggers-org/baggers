/* e68d2020c683d4ab8b07d1016ad44fbb57078cb3
 * This file is automatically generated by graphql-let. */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import * as Apollo from '@apollo/client';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export declare type RequireFields<T, K extends keyof T> = {
    [X in Exclude<keyof T, K>]?: T[X];
} & {
    [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    JSON: any;
    /** The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field. */
    MongoID: any;
    /** The string representation of JavaScript regexp. You may provide it with flags "/^abc.*\/i" or without flags like "^abc.*". More info about RegExp characters and flags: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
    RegExpAsString: any;
};
export declare type CreateOnePortfolioInput = {
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
};
export declare type CreateOnePortfolioPayload = {
    __typename?: 'CreateOnePortfolioPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Created document */
    record?: Maybe<Portfolio>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type CreateOnePositionInput = {
    owner?: Maybe<Scalars['String']>;
    portfolio: Scalars['MongoID'];
    symbol: Scalars['MongoID'];
    private?: Maybe<Scalars['Boolean']>;
    exposure?: Maybe<Scalars['Float']>;
    averagePrice: Scalars['Float'];
    marketValue?: Maybe<Scalars['Float']>;
    costBasis?: Maybe<Scalars['Float']>;
    brokerFees?: Maybe<Scalars['Float']>;
    numberOfShares: Scalars['Float'];
    profitLossUsd?: Maybe<Scalars['Float']>;
    profitLossPercent?: Maybe<Scalars['Float']>;
    dailyProfitLossUsd?: Maybe<Scalars['Float']>;
};
export declare type CreateOnePositionPayload = {
    __typename?: 'CreateOnePositionPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Created document */
    record?: Maybe<Position>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type ErrorInterface = {
    /** Generic error message */
    message?: Maybe<Scalars['String']>;
};
export declare type FilterFindManyPortfolioInput = {
    owner?: Maybe<Scalars['String']>;
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
    positions?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
    _id?: Maybe<Scalars['MongoID']>;
    /** List of *indexed* fields that can be filtered via operators. */
    _operators?: Maybe<FilterFindManyPortfolioOperatorsInput>;
    OR?: Maybe<Array<FilterFindManyPortfolioInput>>;
    AND?: Maybe<Array<FilterFindManyPortfolioInput>>;
};
/** For performance reason this type contains only *indexed* fields. */
export declare type FilterFindManyPortfolioOperatorsInput = {
    owner?: Maybe<FilterFindManyPortfolioOwnerOperatorsInput>;
    _id?: Maybe<FilterFindManyPortfolio_IdOperatorsInput>;
};
export declare type FilterFindManyPortfolioOwnerOperatorsInput = {
    gt?: Maybe<Scalars['String']>;
    gte?: Maybe<Scalars['String']>;
    lt?: Maybe<Scalars['String']>;
    lte?: Maybe<Scalars['String']>;
    ne?: Maybe<Scalars['String']>;
    in?: Maybe<Array<Maybe<Scalars['String']>>>;
    nin?: Maybe<Array<Maybe<Scalars['String']>>>;
    regex?: Maybe<Scalars['RegExpAsString']>;
    exists?: Maybe<Scalars['Boolean']>;
};
export declare type FilterFindManyPortfolio_IdOperatorsInput = {
    gt?: Maybe<Scalars['MongoID']>;
    gte?: Maybe<Scalars['MongoID']>;
    lt?: Maybe<Scalars['MongoID']>;
    lte?: Maybe<Scalars['MongoID']>;
    ne?: Maybe<Scalars['MongoID']>;
    in?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
    nin?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
    exists?: Maybe<Scalars['Boolean']>;
};
export declare type MongoError = ErrorInterface & {
    __typename?: 'MongoError';
    /** MongoDB error message */
    message?: Maybe<Scalars['String']>;
    /** MongoDB error code */
    code?: Maybe<Scalars['Int']>;
};
export declare type Mutation = {
    __typename?: 'Mutation';
    /** Create one document with mongoose defaults, setters, hooks and validation */
    addPosition?: Maybe<CreateOnePositionPayload>;
    /** Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document. */
    removePosition?: Maybe<RemoveByIdPositionPayload>;
    removePositions?: Maybe<RemoveManyPositionPayload>;
    /** Create one document with mongoose defaults, setters, hooks and validation */
    createPortfolio?: Maybe<CreateOnePortfolioPayload>;
    /** Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it. */
    updatePortfolio?: Maybe<UpdateByIdPortfolioPayload>;
    /** Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document. */
    removePortfolio?: Maybe<RemoveByIdPortfolioPayload>;
};
export declare type MutationAddPositionArgs = {
    record: CreateOnePositionInput;
};
export declare type MutationRemovePositionArgs = {
    _id: Scalars['MongoID'];
};
export declare type MutationRemovePositionsArgs = {
    ids?: Maybe<Array<Maybe<Scalars['MongoID']>>>;
};
export declare type MutationCreatePortfolioArgs = {
    record: CreateOnePortfolioInput;
};
export declare type MutationUpdatePortfolioArgs = {
    _id: Scalars['MongoID'];
    record: UpdateByIdPortfolioInput;
};
export declare type MutationRemovePortfolioArgs = {
    _id: Scalars['MongoID'];
};
export declare type PaginationInfo = {
    __typename?: 'PaginationInfo';
    currentPage: Scalars['Int'];
    perPage: Scalars['Int'];
    pageCount?: Maybe<Scalars['Int']>;
    itemCount?: Maybe<Scalars['Int']>;
    hasNextPage?: Maybe<Scalars['Boolean']>;
    hasPreviousPage?: Maybe<Scalars['Boolean']>;
};
export declare type Portfolio = {
    __typename?: 'Portfolio';
    owner?: Maybe<Scalars['String']>;
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
    positions?: Maybe<PositionPagination>;
    _id: Scalars['MongoID'];
};
export declare type PortfolioPositionsArgs = {
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
};
export declare type Position = {
    __typename?: 'Position';
    owner?: Maybe<Scalars['String']>;
    portfolio?: Maybe<Scalars['MongoID']>;
    symbol?: Maybe<Symbol>;
    private?: Maybe<Scalars['Boolean']>;
    exposure?: Maybe<Scalars['Float']>;
    averagePrice?: Maybe<Scalars['Float']>;
    marketValue?: Maybe<Scalars['Float']>;
    costBasis?: Maybe<Scalars['Float']>;
    brokerFees?: Maybe<Scalars['Float']>;
    numberOfShares?: Maybe<Scalars['Float']>;
    profitLossUsd?: Maybe<Scalars['Float']>;
    profitLossPercent?: Maybe<Scalars['Float']>;
    dailyProfitLossUsd?: Maybe<Scalars['Float']>;
    _id: Scalars['MongoID'];
};
/** List of items with pagination. */
export declare type PositionPagination = {
    __typename?: 'PositionPagination';
    /** Total object count. */
    count?: Maybe<Scalars['Int']>;
    /** Array of objects. */
    items?: Maybe<Array<Position>>;
    /** Information to aid in pagination. */
    pageInfo: PaginationInfo;
};
export declare type PositionsFilter = {
    portfolio?: Maybe<Scalars['MongoID']>;
    isEtf?: Maybe<Scalars['Boolean']>;
    exchange?: Maybe<Scalars['String']>;
    country?: Maybe<Scalars['String']>;
};
export declare enum PositionsSort {
    CostBasisAsc = "COST_BASIS_ASC",
    CostBasisDesc = "COST_BASIS_DESC",
    MarketValueAsc = "MARKET_VALUE_ASC",
    MarketValueDesc = "MARKET_VALUE_DESC",
    ProfitLossUsdAsc = "PROFIT_LOSS_USD_ASC",
    ProfitLossUsdDesc = "PROFIT_LOSS_USD_DESC",
    SymbolSymbolAsc = "SYMBOL_SYMBOL_ASC",
    SymbolSymbolDesc = "SYMBOL_SYMBOL_DESC",
    SymbolSecurityNameAsc = "SYMBOL_SECURITY_NAME_ASC",
    SymbolSecurityNameDesc = "SYMBOL_SECURITY_NAME_DESC",
    SymbolQuoteChangeAsc = "SYMBOL_QUOTE_CHANGE_ASC",
    SymbolQuoteChangeDesc = "SYMBOL_QUOTE_CHANGE_DESC",
    SymbolQuoteChangePercentAsc = "SYMBOL_QUOTE_CHANGE_PERCENT_ASC",
    SymbolQuoteChangePercentDesc = "SYMBOL_QUOTE_CHANGE_PERCENT_DESC",
    SymbolQuoteLatestPriceAsc = "SYMBOL_QUOTE_LATEST_PRICE_ASC",
    SymbolQuoteLatestPriceDesc = "SYMBOL_QUOTE_LATEST_PRICE_DESC",
    SymbolQuoteVolumeAsc = "SYMBOL_QUOTE_VOLUME_ASC",
    SymbolQuoteVolumeDesc = "SYMBOL_QUOTE_VOLUME_DESC"
}
export declare type Query = {
    __typename?: 'Query';
    myPositions?: Maybe<PositionPagination>;
    getPositions?: Maybe<PositionPagination>;
    myPortfolios: Array<Portfolio>;
    getPortfolioById?: Maybe<Portfolio>;
    searchSymbols?: Maybe<Array<Maybe<Symbol>>>;
};
export declare type QueryMyPositionsArgs = {
    filter?: Maybe<PositionsFilter>;
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
};
export declare type QueryGetPositionsArgs = {
    filter?: Maybe<PositionsFilter>;
    sort?: Maybe<PositionsSort>;
    perPage?: Maybe<Scalars['Int']>;
    page?: Maybe<Scalars['Int']>;
};
export declare type QueryMyPortfoliosArgs = {
    filter?: Maybe<FilterFindManyPortfolioInput>;
    skip?: Maybe<Scalars['Int']>;
    limit?: Maybe<Scalars['Int']>;
    sort?: Maybe<SortFindManyPortfolioInput>;
};
export declare type QueryGetPortfolioByIdArgs = {
    _id: Scalars['MongoID'];
};
export declare type QuerySearchSymbolsArgs = {
    search: Scalars['String'];
};
export declare type Quote = {
    __typename?: 'Quote';
    symbol?: Maybe<Scalars['MongoID']>;
    change?: Maybe<Scalars['Float']>;
    changePercent?: Maybe<Scalars['Float']>;
    latestPrice?: Maybe<Scalars['Float']>;
    latestUpdate?: Maybe<Scalars['Float']>;
    extendedPrice?: Maybe<Scalars['Float']>;
    extendedUpdate?: Maybe<Scalars['Float']>;
    volume?: Maybe<Scalars['Float']>;
    companyName?: Maybe<Scalars['String']>;
    primaryExchange?: Maybe<Scalars['String']>;
    calculationPrice?: Maybe<Scalars['String']>;
    open?: Maybe<Scalars['Float']>;
    openTime?: Maybe<Scalars['Float']>;
    openSource?: Maybe<Scalars['String']>;
    close?: Maybe<Scalars['Float']>;
    closeTime?: Maybe<Scalars['Float']>;
    closeSource?: Maybe<Scalars['String']>;
    high?: Maybe<Scalars['Float']>;
    highTime?: Maybe<Scalars['Float']>;
    highSource?: Maybe<Scalars['String']>;
    low?: Maybe<Scalars['Float']>;
    lowTime?: Maybe<Scalars['Float']>;
    lowSource?: Maybe<Scalars['String']>;
    latestSource?: Maybe<Scalars['String']>;
    latestTime?: Maybe<Scalars['String']>;
    latestVolume?: Maybe<Scalars['Float']>;
    iexRealtimePrice?: Maybe<Scalars['Float']>;
    iexRealtimeSize?: Maybe<Scalars['Float']>;
    iexLastUpdated?: Maybe<Scalars['Float']>;
    delayedPrice?: Maybe<Scalars['Float']>;
    delayedPriceTime?: Maybe<Scalars['Float']>;
    oddLotDelayedPrice?: Maybe<Scalars['Float']>;
    oddLotDelayedPriceTime?: Maybe<Scalars['Float']>;
    extendedChange?: Maybe<Scalars['Float']>;
    extendedChangePercent?: Maybe<Scalars['Float']>;
    extendedPriceTime?: Maybe<Scalars['Float']>;
    previousClose?: Maybe<Scalars['Float']>;
    previousVolume?: Maybe<Scalars['Float']>;
    iexMarketPercent?: Maybe<Scalars['Float']>;
    iexVolume?: Maybe<Scalars['Float']>;
    avgTotalVolume?: Maybe<Scalars['Float']>;
    iexBidPrice?: Maybe<Scalars['Float']>;
    iexBidSize?: Maybe<Scalars['Float']>;
    iexAskPrice?: Maybe<Scalars['Float']>;
    iexAskSize?: Maybe<Scalars['Float']>;
    iexOpen?: Maybe<Scalars['Float']>;
    iexOpenTime?: Maybe<Scalars['Float']>;
    iexClose?: Maybe<Scalars['Float']>;
    iexCloseTime?: Maybe<Scalars['Float']>;
    marketCap?: Maybe<Scalars['Float']>;
    peRatio?: Maybe<Scalars['Float']>;
    week52High?: Maybe<Scalars['Float']>;
    week52Low?: Maybe<Scalars['Float']>;
    ytdChange?: Maybe<Scalars['Float']>;
    lastTradeTime?: Maybe<Scalars['Float']>;
    isUSMarketOpen?: Maybe<Scalars['Boolean']>;
    _id: Scalars['MongoID'];
};
export declare type RemoveByIdPortfolioPayload = {
    __typename?: 'RemoveByIdPortfolioPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Removed document */
    record?: Maybe<Portfolio>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type RemoveByIdPositionPayload = {
    __typename?: 'RemoveByIdPositionPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Removed document */
    record?: Maybe<Position>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type RemoveManyPositionPayload = {
    __typename?: 'RemoveManyPositionPayload';
    /** Affected documents number */
    numAffected?: Maybe<Scalars['Int']>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type RuntimeError = ErrorInterface & {
    __typename?: 'RuntimeError';
    /** Runtime error message */
    message?: Maybe<Scalars['String']>;
};
export declare enum SortFindManyPortfolioInput {
    IdAsc = "_ID_ASC",
    IdDesc = "_ID_DESC",
    OwnerAsc = "OWNER_ASC",
    OwnerDesc = "OWNER_DESC"
}
export declare type Symbol = {
    __typename?: 'Symbol';
    symbol?: Maybe<Scalars['String']>;
    securityName?: Maybe<Scalars['String']>;
    isEtf?: Maybe<Scalars['Boolean']>;
    exchange?: Maybe<Scalars['String']>;
    country?: Maybe<Scalars['String']>;
    quote?: Maybe<Quote>;
    _id: Scalars['MongoID'];
};
export declare type UpdateByIdPortfolioInput = {
    private?: Maybe<Scalars['Boolean']>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    cash?: Maybe<Scalars['Float']>;
    totalValue?: Maybe<Scalars['Float']>;
};
export declare type UpdateByIdPortfolioPayload = {
    __typename?: 'UpdateByIdPortfolioPayload';
    /** Document ID */
    recordId?: Maybe<Scalars['MongoID']>;
    /** Updated document */
    record?: Maybe<Portfolio>;
    /** Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response. */
    error?: Maybe<ErrorInterface>;
};
export declare type ValidationError = ErrorInterface & {
    __typename?: 'ValidationError';
    /** Combined error message from all validators */
    message?: Maybe<Scalars['String']>;
    /** List of validator errors */
    errors?: Maybe<Array<ValidatorError>>;
};
export declare type ValidatorError = {
    __typename?: 'ValidatorError';
    /** Validation error message */
    message?: Maybe<Scalars['String']>;
    /** Source of the validation error from the model path */
    path?: Maybe<Scalars['String']>;
    /** Field value which occurs the validation error */
    value?: Maybe<Scalars['JSON']>;
    /** Input record idx in array which occurs the validation error. This `idx` is useful for createMany operation. For singular operations it always be 0. For *Many operations `idx` represents record index in array received from user. */
    idx: Scalars['Int'];
};
export declare type CreatePortfolioMutationVariables = Exact<{
    record: CreateOnePortfolioInput;
}>;
export declare type CreatePortfolioMutation = ({
    __typename?: 'Mutation';
} & {
    createPortfolio?: Maybe<({
        __typename?: 'CreateOnePortfolioPayload';
    } & {
        error?: Maybe<({
            __typename?: 'MongoError';
        } & Pick<MongoError, 'message'>) | ({
            __typename?: 'RuntimeError';
        } & Pick<RuntimeError, 'message'>) | ({
            __typename?: 'ValidationError';
        } & Pick<ValidationError, 'message'>)>;
        record?: Maybe<({
            __typename?: 'Portfolio';
        } & Pick<Portfolio, '_id' | 'owner' | 'name' | 'description'>)>;
    })>;
});
export declare type UpdatePortfolioMutationVariables = Exact<{
    id: Scalars['MongoID'];
    record: UpdateByIdPortfolioInput;
}>;
export declare type UpdatePortfolioMutation = ({
    __typename?: 'Mutation';
} & {
    updatePortfolio?: Maybe<({
        __typename?: 'UpdateByIdPortfolioPayload';
    } & {
        error?: Maybe<({
            __typename?: 'MongoError';
        } & Pick<MongoError, 'message'>) | ({
            __typename?: 'RuntimeError';
        } & Pick<RuntimeError, 'message'>) | ({
            __typename?: 'ValidationError';
        } & Pick<ValidationError, 'message'>)>;
        record?: Maybe<({
            __typename?: 'Portfolio';
        } & Pick<Portfolio, '_id' | 'owner' | 'private' | 'name' | 'description'>)>;
    })>;
});
export declare type AddPositionMutationVariables = Exact<{
    record: CreateOnePositionInput;
}>;
export declare type AddPositionMutation = ({
    __typename?: 'Mutation';
} & {
    addPosition?: Maybe<({
        __typename?: 'CreateOnePositionPayload';
    } & Pick<CreateOnePositionPayload, 'recordId'> & {
        error?: Maybe<({
            __typename?: 'MongoError';
        } & Pick<MongoError, 'message'>) | ({
            __typename?: 'RuntimeError';
        } & Pick<RuntimeError, 'message'>) | ({
            __typename?: 'ValidationError';
        } & Pick<ValidationError, 'message'>)>;
        record?: Maybe<({
            __typename?: 'Position';
        } & Pick<Position, '_id' | 'owner' | 'numberOfShares' | 'averagePrice' | 'profitLossPercent' | 'costBasis' | 'marketValue'> & {
            symbol?: Maybe<({
                __typename?: 'Symbol';
            } & Pick<Symbol, '_id' | 'symbol' | 'securityName'> & {
                quote?: Maybe<({
                    __typename?: 'Quote';
                } & Pick<Quote, '_id' | 'latestPrice'>)>;
            })>;
        })>;
    })>;
});
export declare type RemovePositionMutationVariables = Exact<{
    id: Scalars['MongoID'];
}>;
export declare type RemovePositionMutation = ({
    __typename?: 'Mutation';
} & {
    removePosition?: Maybe<({
        __typename?: 'RemoveByIdPositionPayload';
    } & {
        error?: Maybe<({
            __typename?: 'MongoError';
        } & Pick<MongoError, 'message'>) | ({
            __typename?: 'RuntimeError';
        } & Pick<RuntimeError, 'message'>) | ({
            __typename?: 'ValidationError';
        } & Pick<ValidationError, 'message'>)>;
    })>;
});
export declare type RemovePositionsMutationVariables = Exact<{
    ids: Array<Scalars['MongoID']> | Scalars['MongoID'];
}>;
export declare type RemovePositionsMutation = ({
    __typename?: 'Mutation';
} & {
    removePositions?: Maybe<({
        __typename?: 'RemoveManyPositionPayload';
    } & Pick<RemoveManyPositionPayload, 'numAffected'>)>;
});
export declare type ResolverTypeWrapper<T> = Promise<T> | T;
export declare type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export declare type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
    selectionSet: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export declare type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export declare type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | StitchingResolver<TResult, TParent, TContext, TArgs>;
export declare type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;
export declare type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;
export declare type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{
        [key in TKey]: TResult;
    }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, {
        [key in TKey]: TResult;
    }, TContext, TArgs>;
}
export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}
export declare type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;
export declare type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;
export declare type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;
export declare type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;
export declare type NextResolverFn<T> = () => Promise<T>;
export declare type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
/** Mapping between all available schema types and the resolvers types */
export declare type ResolversTypes = {
    CreateOnePortfolioInput: CreateOnePortfolioInput;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
    String: ResolverTypeWrapper<Scalars['String']>;
    Float: ResolverTypeWrapper<Scalars['Float']>;
    CreateOnePortfolioPayload: ResolverTypeWrapper<CreateOnePortfolioPayload>;
    CreateOnePositionInput: CreateOnePositionInput;
    CreateOnePositionPayload: ResolverTypeWrapper<CreateOnePositionPayload>;
    ErrorInterface: ResolversTypes['MongoError'] | ResolversTypes['RuntimeError'] | ResolversTypes['ValidationError'];
    FilterFindManyPortfolioInput: FilterFindManyPortfolioInput;
    FilterFindManyPortfolioOperatorsInput: FilterFindManyPortfolioOperatorsInput;
    FilterFindManyPortfolioOwnerOperatorsInput: FilterFindManyPortfolioOwnerOperatorsInput;
    FilterFindManyPortfolio_idOperatorsInput: FilterFindManyPortfolio_IdOperatorsInput;
    JSON: ResolverTypeWrapper<Scalars['JSON']>;
    MongoError: ResolverTypeWrapper<MongoError>;
    Int: ResolverTypeWrapper<Scalars['Int']>;
    MongoID: ResolverTypeWrapper<Scalars['MongoID']>;
    Mutation: ResolverTypeWrapper<{}>;
    PaginationInfo: ResolverTypeWrapper<PaginationInfo>;
    Portfolio: ResolverTypeWrapper<Portfolio>;
    Position: ResolverTypeWrapper<Position>;
    PositionPagination: ResolverTypeWrapper<PositionPagination>;
    PositionsFilter: PositionsFilter;
    PositionsSort: PositionsSort;
    Query: ResolverTypeWrapper<{}>;
    Quote: ResolverTypeWrapper<Quote>;
    RegExpAsString: ResolverTypeWrapper<Scalars['RegExpAsString']>;
    RemoveByIdPortfolioPayload: ResolverTypeWrapper<RemoveByIdPortfolioPayload>;
    RemoveByIdPositionPayload: ResolverTypeWrapper<RemoveByIdPositionPayload>;
    RemoveManyPositionPayload: ResolverTypeWrapper<RemoveManyPositionPayload>;
    RuntimeError: ResolverTypeWrapper<RuntimeError>;
    SortFindManyPortfolioInput: SortFindManyPortfolioInput;
    Symbol: ResolverTypeWrapper<Symbol>;
    UpdateByIdPortfolioInput: UpdateByIdPortfolioInput;
    UpdateByIdPortfolioPayload: ResolverTypeWrapper<UpdateByIdPortfolioPayload>;
    ValidationError: ResolverTypeWrapper<ValidationError>;
    ValidatorError: ResolverTypeWrapper<ValidatorError>;
};
/** Mapping between all available schema types and the resolvers parents */
export declare type ResolversParentTypes = {
    CreateOnePortfolioInput: CreateOnePortfolioInput;
    Boolean: Scalars['Boolean'];
    String: Scalars['String'];
    Float: Scalars['Float'];
    CreateOnePortfolioPayload: CreateOnePortfolioPayload;
    CreateOnePositionInput: CreateOnePositionInput;
    CreateOnePositionPayload: CreateOnePositionPayload;
    ErrorInterface: ResolversParentTypes['MongoError'] | ResolversParentTypes['RuntimeError'] | ResolversParentTypes['ValidationError'];
    FilterFindManyPortfolioInput: FilterFindManyPortfolioInput;
    FilterFindManyPortfolioOperatorsInput: FilterFindManyPortfolioOperatorsInput;
    FilterFindManyPortfolioOwnerOperatorsInput: FilterFindManyPortfolioOwnerOperatorsInput;
    FilterFindManyPortfolio_idOperatorsInput: FilterFindManyPortfolio_IdOperatorsInput;
    JSON: Scalars['JSON'];
    MongoError: MongoError;
    Int: Scalars['Int'];
    MongoID: Scalars['MongoID'];
    Mutation: {};
    PaginationInfo: PaginationInfo;
    Portfolio: Portfolio;
    Position: Position;
    PositionPagination: PositionPagination;
    PositionsFilter: PositionsFilter;
    Query: {};
    Quote: Quote;
    RegExpAsString: Scalars['RegExpAsString'];
    RemoveByIdPortfolioPayload: RemoveByIdPortfolioPayload;
    RemoveByIdPositionPayload: RemoveByIdPositionPayload;
    RemoveManyPositionPayload: RemoveManyPositionPayload;
    RuntimeError: RuntimeError;
    Symbol: Symbol;
    UpdateByIdPortfolioInput: UpdateByIdPortfolioInput;
    UpdateByIdPortfolioPayload: UpdateByIdPortfolioPayload;
    ValidationError: ValidationError;
    ValidatorError: ValidatorError;
};
export declare type CreateOnePortfolioPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOnePortfolioPayload'] = ResolversParentTypes['CreateOnePortfolioPayload']> = {
    recordId?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    record?: Resolver<Maybe<ResolversTypes['Portfolio']>, ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['ErrorInterface']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CreateOnePositionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOnePositionPayload'] = ResolversParentTypes['CreateOnePositionPayload']> = {
    recordId?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    record?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['ErrorInterface']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ErrorInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ErrorInterface'] = ResolversParentTypes['ErrorInterface']> = {
    __resolveType: TypeResolveFn<'MongoError' | 'RuntimeError' | 'ValidationError', ParentType, ContextType>;
    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};
export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}
export declare type MongoErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MongoError'] = ResolversParentTypes['MongoError']> = {
    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    code?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export interface MongoIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MongoID'], any> {
    name: 'MongoID';
}
export declare type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
    addPosition?: Resolver<Maybe<ResolversTypes['CreateOnePositionPayload']>, ParentType, ContextType, RequireFields<MutationAddPositionArgs, 'record'>>;
    removePosition?: Resolver<Maybe<ResolversTypes['RemoveByIdPositionPayload']>, ParentType, ContextType, RequireFields<MutationRemovePositionArgs, '_id'>>;
    removePositions?: Resolver<Maybe<ResolversTypes['RemoveManyPositionPayload']>, ParentType, ContextType, RequireFields<MutationRemovePositionsArgs, never>>;
    createPortfolio?: Resolver<Maybe<ResolversTypes['CreateOnePortfolioPayload']>, ParentType, ContextType, RequireFields<MutationCreatePortfolioArgs, 'record'>>;
    updatePortfolio?: Resolver<Maybe<ResolversTypes['UpdateByIdPortfolioPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePortfolioArgs, '_id' | 'record'>>;
    removePortfolio?: Resolver<Maybe<ResolversTypes['RemoveByIdPortfolioPayload']>, ParentType, ContextType, RequireFields<MutationRemovePortfolioArgs, '_id'>>;
};
export declare type PaginationInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaginationInfo'] = ResolversParentTypes['PaginationInfo']> = {
    currentPage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    perPage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    itemCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    hasNextPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    hasPreviousPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PortfolioResolvers<ContextType = any, ParentType extends ResolversParentTypes['Portfolio'] = ResolversParentTypes['Portfolio']> = {
    owner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    private?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    cash?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    totalValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    positions?: Resolver<Maybe<ResolversTypes['PositionPagination']>, ParentType, ContextType, RequireFields<PortfolioPositionsArgs, never>>;
    _id?: Resolver<ResolversTypes['MongoID'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PositionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Position'] = ResolversParentTypes['Position']> = {
    owner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    portfolio?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    symbol?: Resolver<Maybe<ResolversTypes['Symbol']>, ParentType, ContextType>;
    private?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    exposure?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    averagePrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    marketValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    costBasis?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    brokerFees?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    numberOfShares?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    profitLossUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    profitLossPercent?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    dailyProfitLossUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    _id?: Resolver<ResolversTypes['MongoID'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PositionPaginationResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionPagination'] = ResolversParentTypes['PositionPagination']> = {
    count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    items?: Resolver<Maybe<Array<ResolversTypes['Position']>>, ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PaginationInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
    myPositions?: Resolver<Maybe<ResolversTypes['PositionPagination']>, ParentType, ContextType, RequireFields<QueryMyPositionsArgs, never>>;
    getPositions?: Resolver<Maybe<ResolversTypes['PositionPagination']>, ParentType, ContextType, RequireFields<QueryGetPositionsArgs, never>>;
    myPortfolios?: Resolver<Array<ResolversTypes['Portfolio']>, ParentType, ContextType, RequireFields<QueryMyPortfoliosArgs, 'limit'>>;
    getPortfolioById?: Resolver<Maybe<ResolversTypes['Portfolio']>, ParentType, ContextType, RequireFields<QueryGetPortfolioByIdArgs, '_id'>>;
    searchSymbols?: Resolver<Maybe<Array<Maybe<ResolversTypes['Symbol']>>>, ParentType, ContextType, RequireFields<QuerySearchSymbolsArgs, 'search'>>;
};
export declare type QuoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['Quote'] = ResolversParentTypes['Quote']> = {
    symbol?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    change?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    changePercent?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    latestPrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    latestUpdate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    extendedPrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    extendedUpdate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    volume?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    primaryExchange?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    calculationPrice?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    open?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    openTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    openSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    close?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    closeTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    closeSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    high?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    highTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    highSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    low?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    lowTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    lowSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    latestSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    latestTime?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    latestVolume?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexRealtimePrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexRealtimeSize?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexLastUpdated?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    delayedPrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    delayedPriceTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    oddLotDelayedPrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    oddLotDelayedPriceTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    extendedChange?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    extendedChangePercent?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    extendedPriceTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    previousClose?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    previousVolume?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexMarketPercent?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexVolume?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    avgTotalVolume?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexBidPrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexBidSize?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexAskPrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexAskSize?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexOpen?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexOpenTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexClose?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    iexCloseTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    marketCap?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    peRatio?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    week52High?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    week52Low?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    ytdChange?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    lastTradeTime?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    isUSMarketOpen?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    _id?: Resolver<ResolversTypes['MongoID'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export interface RegExpAsStringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['RegExpAsString'], any> {
    name: 'RegExpAsString';
}
export declare type RemoveByIdPortfolioPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveByIdPortfolioPayload'] = ResolversParentTypes['RemoveByIdPortfolioPayload']> = {
    recordId?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    record?: Resolver<Maybe<ResolversTypes['Portfolio']>, ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['ErrorInterface']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type RemoveByIdPositionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveByIdPositionPayload'] = ResolversParentTypes['RemoveByIdPositionPayload']> = {
    recordId?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    record?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['ErrorInterface']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type RemoveManyPositionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveManyPositionPayload'] = ResolversParentTypes['RemoveManyPositionPayload']> = {
    numAffected?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['ErrorInterface']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type RuntimeErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuntimeError'] = ResolversParentTypes['RuntimeError']> = {
    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type SymbolResolvers<ContextType = any, ParentType extends ResolversParentTypes['Symbol'] = ResolversParentTypes['Symbol']> = {
    symbol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    securityName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    isEtf?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    exchange?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType>;
    _id?: Resolver<ResolversTypes['MongoID'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type UpdateByIdPortfolioPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateByIdPortfolioPayload'] = ResolversParentTypes['UpdateByIdPortfolioPayload']> = {
    recordId?: Resolver<Maybe<ResolversTypes['MongoID']>, ParentType, ContextType>;
    record?: Resolver<Maybe<ResolversTypes['Portfolio']>, ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['ErrorInterface']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ValidationErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ValidationError'] = ResolversParentTypes['ValidationError']> = {
    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    errors?: Resolver<Maybe<Array<ResolversTypes['ValidatorError']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ValidatorErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ValidatorError'] = ResolversParentTypes['ValidatorError']> = {
    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
    idx?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type Resolvers<ContextType = any> = {
    CreateOnePortfolioPayload?: CreateOnePortfolioPayloadResolvers<ContextType>;
    CreateOnePositionPayload?: CreateOnePositionPayloadResolvers<ContextType>;
    ErrorInterface?: ErrorInterfaceResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    MongoError?: MongoErrorResolvers<ContextType>;
    MongoID?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    PaginationInfo?: PaginationInfoResolvers<ContextType>;
    Portfolio?: PortfolioResolvers<ContextType>;
    Position?: PositionResolvers<ContextType>;
    PositionPagination?: PositionPaginationResolvers<ContextType>;
    Query?: QueryResolvers<ContextType>;
    Quote?: QuoteResolvers<ContextType>;
    RegExpAsString?: GraphQLScalarType;
    RemoveByIdPortfolioPayload?: RemoveByIdPortfolioPayloadResolvers<ContextType>;
    RemoveByIdPositionPayload?: RemoveByIdPositionPayloadResolvers<ContextType>;
    RemoveManyPositionPayload?: RemoveManyPositionPayloadResolvers<ContextType>;
    RuntimeError?: RuntimeErrorResolvers<ContextType>;
    Symbol?: SymbolResolvers<ContextType>;
    UpdateByIdPortfolioPayload?: UpdateByIdPortfolioPayloadResolvers<ContextType>;
    ValidationError?: ValidationErrorResolvers<ContextType>;
    ValidatorError?: ValidatorErrorResolvers<ContextType>;
};
/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export declare type IResolvers<ContextType = any> = Resolvers<ContextType>;
export declare const CreatePortfolioDocument: Apollo.DocumentNode;
export declare type CreatePortfolioMutationFn = Apollo.MutationFunction<CreatePortfolioMutation, CreatePortfolioMutationVariables>;
/**
 * __useCreatePortfolioMutation__
 *
 * To run a mutation, you first call `useCreatePortfolioMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePortfolioMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPortfolioMutation, { data, loading, error }] = useCreatePortfolioMutation({
 *   variables: {
 *      record: // value for 'record'
 *   },
 * });
 */
export declare function useCreatePortfolioMutation(baseOptions?: Apollo.MutationHookOptions<CreatePortfolioMutation, CreatePortfolioMutationVariables>): Apollo.MutationTuple<CreatePortfolioMutation, Exact<{
    record: CreateOnePortfolioInput;
}>>;
export declare type CreatePortfolioMutationHookResult = ReturnType<typeof useCreatePortfolioMutation>;
export declare type CreatePortfolioMutationResult = Apollo.MutationResult<CreatePortfolioMutation>;
export declare type CreatePortfolioMutationOptions = Apollo.BaseMutationOptions<CreatePortfolioMutation, CreatePortfolioMutationVariables>;
export declare const UpdatePortfolioDocument: Apollo.DocumentNode;
export declare type UpdatePortfolioMutationFn = Apollo.MutationFunction<UpdatePortfolioMutation, UpdatePortfolioMutationVariables>;
/**
 * __useUpdatePortfolioMutation__
 *
 * To run a mutation, you first call `useUpdatePortfolioMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePortfolioMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePortfolioMutation, { data, loading, error }] = useUpdatePortfolioMutation({
 *   variables: {
 *      id: // value for 'id'
 *      record: // value for 'record'
 *   },
 * });
 */
export declare function useUpdatePortfolioMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePortfolioMutation, UpdatePortfolioMutationVariables>): Apollo.MutationTuple<UpdatePortfolioMutation, Exact<{
    id: any;
    record: UpdateByIdPortfolioInput;
}>>;
export declare type UpdatePortfolioMutationHookResult = ReturnType<typeof useUpdatePortfolioMutation>;
export declare type UpdatePortfolioMutationResult = Apollo.MutationResult<UpdatePortfolioMutation>;
export declare type UpdatePortfolioMutationOptions = Apollo.BaseMutationOptions<UpdatePortfolioMutation, UpdatePortfolioMutationVariables>;
export declare const AddPositionDocument: Apollo.DocumentNode;
export declare type AddPositionMutationFn = Apollo.MutationFunction<AddPositionMutation, AddPositionMutationVariables>;
/**
 * __useAddPositionMutation__
 *
 * To run a mutation, you first call `useAddPositionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPositionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPositionMutation, { data, loading, error }] = useAddPositionMutation({
 *   variables: {
 *      record: // value for 'record'
 *   },
 * });
 */
export declare function useAddPositionMutation(baseOptions?: Apollo.MutationHookOptions<AddPositionMutation, AddPositionMutationVariables>): Apollo.MutationTuple<AddPositionMutation, Exact<{
    record: CreateOnePositionInput;
}>>;
export declare type AddPositionMutationHookResult = ReturnType<typeof useAddPositionMutation>;
export declare type AddPositionMutationResult = Apollo.MutationResult<AddPositionMutation>;
export declare type AddPositionMutationOptions = Apollo.BaseMutationOptions<AddPositionMutation, AddPositionMutationVariables>;
export declare const RemovePositionDocument: Apollo.DocumentNode;
export declare type RemovePositionMutationFn = Apollo.MutationFunction<RemovePositionMutation, RemovePositionMutationVariables>;
/**
 * __useRemovePositionMutation__
 *
 * To run a mutation, you first call `useRemovePositionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemovePositionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removePositionMutation, { data, loading, error }] = useRemovePositionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useRemovePositionMutation(baseOptions?: Apollo.MutationHookOptions<RemovePositionMutation, RemovePositionMutationVariables>): Apollo.MutationTuple<RemovePositionMutation, Exact<{
    id: any;
}>>;
export declare type RemovePositionMutationHookResult = ReturnType<typeof useRemovePositionMutation>;
export declare type RemovePositionMutationResult = Apollo.MutationResult<RemovePositionMutation>;
export declare type RemovePositionMutationOptions = Apollo.BaseMutationOptions<RemovePositionMutation, RemovePositionMutationVariables>;
export declare const RemovePositionsDocument: Apollo.DocumentNode;
export declare type RemovePositionsMutationFn = Apollo.MutationFunction<RemovePositionsMutation, RemovePositionsMutationVariables>;
/**
 * __useRemovePositionsMutation__
 *
 * To run a mutation, you first call `useRemovePositionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemovePositionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removePositionsMutation, { data, loading, error }] = useRemovePositionsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export declare function useRemovePositionsMutation(baseOptions?: Apollo.MutationHookOptions<RemovePositionsMutation, RemovePositionsMutationVariables>): Apollo.MutationTuple<RemovePositionsMutation, Exact<{
    ids: any;
}>>;
export declare type RemovePositionsMutationHookResult = ReturnType<typeof useRemovePositionsMutation>;
export declare type RemovePositionsMutationResult = Apollo.MutationResult<RemovePositionsMutation>;
export declare type RemovePositionsMutationOptions = Apollo.BaseMutationOptions<RemovePositionsMutation, RemovePositionsMutationVariables>;
